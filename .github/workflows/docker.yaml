name: Docker Image Pull and Push to Aliyun

on:
  workflow_dispatch:
  push:
    branches: [ main ]
  schedule:
    - cron: '00 2 * * *'  # 每天凌晨2点UTC执行 [[1]]

env:
  ALIYUN_REGISTRY: "${{ secrets.ALIYUN_REGISTRY }}"
  ALIYUN_NAME_SPACE: "${{ secrets.ALIYUN_NAME_SPACE }}"
  ALIYUN_REGISTRY_USER: "${{ secrets.ALIYUN_REGISTRY_USER }}"
  ALIYUN_REGISTRY_PASSWORD: "${{ secrets.ALIYUN_REGISTRY_PASSWORD }}"
  DOCKER_HUB_USER: "${{ secrets.DOCKER_HUB_USER }}"        # Docker Hub账号 
  DOCKER_HUB_TOKEN: "${{ secrets.DOCKER_HUB_TOKEN }}"      # Docker Hub Token 

jobs:
  build:
    name: Pull and Push Images
    runs-on: ubuntu-latest
    steps:
    # 1. 登录Docker Hub（提升限流阈值） 
    - name: Docker Hub Login
      run: |
        docker login --username=$DOCKER_HUB_USER --password=$DOCKER_HUB_TOKEN

    # 2. 登录阿里云仓库 
    - name: Aliyun Registry Login
      run: |
        docker login -u $ALIYUN_REGISTRY_USER -p $ALIYUN_REGISTRY_PASSWORD $ALIYUN_REGISTRY

    # 3. 磁盘空间优化（清理缓存+调整Docker存储路径） 
    - name: Maximize build space
      uses: easimon/maximize-build-space@master
      with:
        root-reserve-mb: 2048
        swap-size-mb: 128
        remove-dotnet: 'true'
        remove-haskell: 'true'
        build-mount-path: '/var/lib/docker/'

    # 4. 重启Docker服务（确保配置生效）
    - name: Restart Docker
      run: sudo service docker restart

    # 5. 检查磁盘空间状态
    - name: Check Disk Space Before Pull
      run: |
        echo "Before pulling images:"
        df -hT

    # 6. 代码拉取
    - name: Checkout Code
      uses: actions/checkout@v4

    # 7. 配置Docker Buildx（支持多平台构建）
    - name: Docker Setup Buildx
      uses: docker/setup-buildx-action@v3

    # 8. 主流程：拉取、打标签、推送镜像
    - name: Build and Push Images to Aliyun
      env:
        MAX_RETRIES: 5
        RETRY_DELAY: 30
      run: |
        # 定义重试函数（应对限流和网络波动） 
        retry() {
          local retries=$1
          local delay=$2
          shift 2
          for i in $(seq 1 $retries); do
            "${@}" && return || sleep $delay
          done
          echo "Failed to execute: $*"
          exit 1
        }

        # 处理镜像重复名称问题 
        declare -A duplicate_images
        declare -A temp_map
        while IFS= read -r line || [ -n "$line" ]; do
            [[ -z "$line" ]] && continue
            if echo "$line" | grep -q '^\s*#'; then continue; fi
            
            image=$(echo "$line" | awk '{print $NF}' | sed 's/@.*//')
            image_name_tag=$(echo "$image" | awk -F'/' '{print $NF}')
            name_space=$(echo "$image" | awk -F'/' '{if (NF==3) print $2; else if (NF==2) print $1; else print ""}')
            name_space="${name_space}_"
            image_name=$(echo "$image_name_tag" | awk -F':' '{print $1}')
            
            if [[ -n "${temp_map[$image_name]}" ]]; then
                if [[ "${temp_map[$image_name]}" != $name_space ]]; then
                    duplicate_images[$image_name]="true"
                fi
            else
                temp_map[$image_name]=$name_space
            fi       
        done < images.txt

        # 拉取、标签、推送镜像
        count=0
        while IFS= read -r line || [ -n "$line" ]; do
            [[ -z "$line" ]] && continue
            if echo "$line" | grep -q '^\s*#'; then continue; fi
            
            echo "Processing: $line"
            platform=$(echo "$line" | awk -F'--platform[ =]' '{if (NF>1) print $2}' | awk '{print $1}')
            platform_prefix=""
            if [ -n "$platform" ]; then
                platform_prefix="${platform//\//_}_"
            fi
            
            image=$(echo "$line" | awk '{print $NF}' | sed 's/@.*//')
            image_name_tag=$(echo "$image" | awk -F'/' '{print $NF}')
            name_space=$(echo "$image" | awk -F'/' '{if (NF==3) print $2; else if (NF==2) print $1; else print ""}')
            name_space_prefix=""
            if [[ -n "${duplicate_images[$image_name]}" ]]; then
                if [[ -n "${name_space}" ]]; then
                    name_space_prefix="${name_space}_"
                fi
            fi
            
            new_image="$ALIYUN_REGISTRY/$ALIYUN_NAME_SPACE/$platform_prefix$name_space_prefix$image_name_tag"
            
            # **关键优化1：拉取后检查镜像是否存在**
            echo "Pulling $image..."
            retry $MAX_RETRIES $RETRY_DELAY docker pull $image
            if ! docker images | grep -q "$(echo $image | cut -d':' -f1)"; then
              echo "Error: Image $image not found after pull!"
              exit 1
            fi
            
            # **关键优化2：标签前检查源镜像存在性**
            echo "Tagging $image to $new_image"
            if ! docker tag $image $new_image; then
              echo "Error: Failed to tag $image to $new_image"
              exit 1
            fi
            
            # **关键优化3：推送后清理并增加日志**
            echo "Pushing $new_image..."
            retry $MAX_RETRIES $RETRY_DELAY docker push $new_image
            
            echo "Cleaning up $image and $new_image"
            # **关键优化4：分步删除并记录结果**
            echo "Step 1: Deleting image by name"
            docker images | grep "$(echo $image | cut -d':' -f1)" | awk '{print $3}' | xargs --no-run-if-empty sudo docker rmi --force || echo "No matching images to delete for $image"
            
            echo "Step 2: Deleting new image by name"
            docker images | grep "$(echo $new_image | cut -d':' -f1)" | awk '{print $3}' | xargs --no-run-if-empty sudo docker rmi --force || echo "No matching images to delete for $new_image"
            
            # **关键优化5：定期系统清理并忽略错误**
            ((count++))
            if (( count % 3 == 0 )); then
                echo "Step 3: Running system prune"
                sudo docker system prune -af || echo "System prune completed with warnings"
            fi
        done < images.txt

    # 9. 最终系统清理 
    - name: Final Cleanup
      run: |
        echo "Final cleanup..."
        sudo docker system prune -af || echo "Final prune completed with warnings"
        sudo apt-get clean || echo "APT cache cleaned"
        sudo rm -rf /tmp/* ~/.cache/* || echo "Temporary files removed"
