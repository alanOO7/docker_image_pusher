name: Docker Image Pull and Push

on:
  workflow_dispatch:
  push:
    branches: [ main ]
  schedule:
    - cron: '00 23 * * *'  # 每天23:00 UTC触发

env:
  ALIYUN_REGISTRY: "${{ secrets.ALIYUN_REGISTRY }}"          # 阿里云镜像仓库地址
  ALIYUN_NAME_SPACE: "${{ secrets.ALIYUN_NAME_SPACE }}"      # 阿里云命名空间
  ALIYUN_REGISTRY_USER: "${{ secrets.ALIYUN_REGISTRY_USER }}"# 阿里云账号
  ALIYUN_REGISTRY_PASSWORD: "${{ secrets.ALIYUN_REGISTRY_PASSWORD }}" # 阿里云密码
  DOCKER_HUB_USER: "${{ secrets.DOCKER_HUB_USER }}"          # Docker Hub账号
  DOCKER_HUB_TOKEN: "${{ secrets.DOCKER_HUB_TOKEN }}"        # Docker Hub Token（推荐使用Personal Access Token）

jobs:
  build:
    name: Pull and Push Docker Images
    runs-on: ubuntu-latest
    steps:
    # 1. 配置阿里云镜像加速器（降低Docker Hub请求压力）
    - name: Configure Aliyun Registry Mirror
      run: |
        sudo mkdir -p /etc/docker
        cat <<EOF | sudo tee /etc/docker/daemon.json
        {
          "registry-mirrors": ["https://<your-aliyun-mirror>.mirror.aliyuncs.com"] 
        }
        EOF
        sudo systemctl daemon-reload
        sudo systemctl restart docker
      # 引用来源：https://help.aliyun.com/document_detail/40521.html  [[5]]

    # 2. 登录Docker Hub和阿里云仓库（提升限流阈值）
    - name: Docker Login
      run: |
        docker login --username=$DOCKER_HUB_USER --password=$DOCKER_HUB_TOKEN
        docker login -u $ALIYUN_REGISTRY_USER -p $ALIYUN_REGISTRY_PASSWORD $ALIYUN_REGISTRY
      # 引用来源：Docker Hub认证提升限流阈值 [[2]]

    # 3. 磁盘空间优化（清理缓存+调整Docker存储路径）
    - name: Maximize build space
      uses: easimon/maximize-build-space@master
      with:
        root-reserve-mb: 2048
        swap-size-mb: 128
        remove-dotnet: 'true'
        remove-haskell: 'true'
        build-mount-path: '/var/lib/docker/'
      # 引用来源：清理缓存和调整存储路径 [[3]]

    # 4. 重启Docker服务（确保配置生效）
    - name: Restart Docker
      run: sudo service docker restart

    # 5. 检查磁盘空间状态
    - name: Check Disk Space Before Pull
      run: |
        echo "Before pulling images:"
        df -hT

    # 6. 代码拉取
    - name: Checkout Code
      uses: actions/checkout@v4

    # 7. 配置Docker Buildx（支持多平台构建）
    - name: Docker Setup Buildx
      uses: docker/setup-buildx-action@v3

    # 8. 主流程：拉取、打标签、推送镜像
    - name: Build and Push Images to Aliyun
      env:
        MAX_RETRIES: 3
        RETRY_DELAY: 10
      run: |
        # 定义重试函数（应对限流和网络波动）
        retry() {
          local retries=$1
          local delay=$2
          shift 2
          for i in $(seq 1 $retries); do
            "${@}" && return || sleep $delay
          done
          echo "Failed to execute: $*"
          exit 1
        }

        # 处理镜像重复名称问题
        declare -A duplicate_images
        declare -A temp_map
        while IFS= read -r line || [ -n "$line" ]; do
            [[ -z "$line" ]] && continue
            if echo "$line" | grep -q '^\s*#'; then continue; fi
            
            image=$(echo "$line" | awk '{print $NF}' | sed 's/@.*//')
            image_name_tag=$(echo "$image" | awk -F'/' '{print $NF}')
            name_space=$(echo "$image" | awk -F'/' '{if (NF==3) print $2; else if (NF==2) print $1; else print ""}')
            name_space="${name_space}_"
            image_name=$(echo "$image_name_tag" | awk -F':' '{print $1}')
            
            if [[ -n "${temp_map[$image_name]}" ]]; then
                if [[ "${temp_map[$image_name]}" != $name_space ]]; then
                    duplicate_images[$image_name]="true"
                fi
            else
                temp_map[$image_name]=$name_space
            fi       
        done < images.txt

        # 拉取、标签、推送镜像
        count=0
        while IFS= read -r line || [ -n "$line" ]; do
            [[ -z "$line" ]] && continue
            if echo "$line" | grep -q '^\s*#'; then continue; fi
            
            echo "Processing: $line"
            platform=$(echo "$line" | awk -F'--platform[ =]' '{if (NF>1) print $2}' | awk '{print $1}')
            platform_prefix=""
            if [ -n "$platform" ]; then
                platform_prefix="${platform//\//_}_"
            fi
            
            image=$(echo "$line" | awk '{print $NF}' | sed 's/@.*//')
            image_name_tag=$(echo "$image" | awk -F'/' '{print $NF}')
            name_space=$(echo "$image" | awk -F'/' '{if (NF==3) print $2; else if (NF==2) print $1; else print ""}')
            name_space_prefix=""
            if [[ -n "${duplicate_images[$image_name]}" ]]; then
                if [[ -n "${name_space}" ]]; then
                    name_space_prefix="${name_space}_"
                fi
            fi
            
            new_image="$ALIYUN_REGISTRY/$ALIYUN_NAME_SPACE/$platform_prefix$name_space_prefix$image_name_tag"
            
            # 带重试的镜像拉取
            echo "Pulling $image..."
            retry $MAX_RETRIES $RETRY_DELAY docker pull $image
            
            # 打标签并推送
            echo "Tagging $image to $new_image"
            docker tag $image $new_image
            
            echo "Pushing $new_image..."
            docker push $new_image
            
            # 即时清理磁盘空间
            echo "Cleaning up $image and $new_image"
            docker rmi $image || true
            docker rmi $new_image || true
            
            # 每处理5个镜像执行系统清理
            ((count++))
            if (( count % 5 == 0 )); then
                docker system prune -af
            fi
        done < images.txt

    # 9. 最终系统清理
    - name: Final Cleanup
      run: |
        echo "Final cleanup..."
        docker system prune -af
        sudo apt-get clean
        sudo rm -rf /tmp/* ~/.cache/*
      # 引用来源：定期清理磁盘空间 [[3]]
